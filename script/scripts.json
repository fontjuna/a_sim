{
    "돌파4시간3분5억_매수": {
        "script": "# 전략평가 결과 전달\nresult = not 돌파4시간3분5억_매도()",
        "type": "bool",
        "desc": ""
    },
    "돌파4시간3분5억_매도": {
        "script": "# 다른종목으로 테스트\n#code = '389140'\n\n# 차트정의\n일 = ChartManager(code, 'dy')\n분 = ChartManager(code, 'mi', 3)\n\necho(f'code={code} 현재가={일.c()}')\n\n# 이동평균정의\nma = 분.ma\n\n# 미리 계산\nc, c1, c_limit = 일.c(), 일.c(1), int(일.c(1) * 1.3)\nv1, v2, v5, v10 = ma(5, 1), ma(5, 2), ma(5), ma(10)\nmo, mc, m_down_rate = 분.o(), 분.c(), ((분.o() - 분.c()) / 분.o())\n\n# 조건정의(결과 값이 논리값이 되도록 작성)\n상한가 = c >= c_limit \n급락 = mo > mc and m_down_rate > 0.03 # 봉하나에 3% 급락\n하락전환_3분5이평 = v2 >= v1 and v1 >= v5 and v5 < v1\n이평역전_3분5_10이평 = v10 > v5\n이평아래 = v10 > mc\n\n# 로깅\nmsg = ''\nif 상한가: \n    msg += f'상한가(전일{c1}, 현재가{c}, 상한가{c_limit})'\nelif 급락: \n    msg += f'급락(시가:{mo}, 현재가:{mc}, 하락률:{m_down_rate})'\nelif 하락전환_3분5이평: \n    msg += f'하락전환_3분5이평(2:{v2}, 1:{v1}, 0:{v5})'\nelif 이평역전_3분5_10이평: \n    msg+= f'이평역전_3분5_10이평(5:{v5}, 10:{v10})'\nelif 이평아래: \n    msg += f'이평아래(이평:{v10}, 현재가:{c})'\n\nif not msg: msg = \" 없음\"\necho(f\"매도조건: code={code} {name}/{msg}\")\n\n# 전략평가 전송\nresult = 상한가 or 하락전환_3분5이평 or 이평역전_3분5_10이평 or 이평아래 or 급락\necho(f'result={result}\\n')",
        "type": "bool",
        "desc": "상한가 이거나\n3분봉 5이평이 하락전환 하거나\n3분봉 5이평이 10이평을 하회 하거나\n현재가가 10이평을 하회 하거나\n3분봉에서 3%이상 급락시 매도"
    },
    "특수주기_매도": {
        "script": "차트7분봉 = CM(code, 'mi', 7)\n\n차트7분봉_5이평 = 차트7분봉.ma(차트7분봉.c, 5)\n\nresult = 차트7분봉_5이평",
        "type": "float",
        "desc": ""
    },
    "indicator": {
        "script": "dy = CM(code, 'dy')\nmi3 = CM(code, 'mi', 3)\n\nma20 = dy.indicator(dy.ma, 20)\necho(f'0={ma20()}, 1={ma20(1)}')\n\nsma5 = mi3.indicator(mi3.ma, 5) # SMA 5 계산 클로저 생성 \nsma10 = mi3.indicator(mi3.ma, 10) \n\ncross = mi3.cross_up(sma5, sma10) # 함수처럼 사용 가능\necho(f'sma5={sma5()}, sma10={sma10()}, cross={cross}')\n\nresult = ma20(0)",
        "type": "float",
        "desc": "indicator와 offset 사용"
    },
    "함수사용": {
        "script": "dy = CM(code, 'dy')\n\n# all_true 함수 사용\nall_conditions_met = dy.all_true([\n    dy.c() > dy.ma(dy.c, 20),\n    dy.v() > dy.ma(dy.v, 20),\n    dy.rsi() < 70\n])\n\n# any_true 함수 사용\nany_condition_met = dy.any_true([\n    dy.c() > dy.h(1),\n    dy.v() > dy.ma(dy.v, 20) * 2,\n    dy.rsi() < 30\n])\n\n# iif 함수 사용\nresult = dy.iif(dy.c() > dy.ma(dy.c, 20), \"상승 추세\", \"하락 추세\")",
        "type": "str",
        "desc": "iif, 사용자 함수"
    },
    "보조지표사용": {
        "script": "cm = ChartManager(code, 'dy')\n\n# RSI (상대강도지수)\nrsi = cm.rsi()                # 기본 14일 RSI\nrsi_9 = cm.rsi(9)             # 9일 RSI\nrsi_prev = cm.rsi(14, 1)      # 1봉 이전의 14일 RSI\n\n# MACD (이동평균수렴확산지수)\nmacd, signal, hist = cm.macd()  # 기본 MACD (12, 26, 9)\nmacd2, signal2, hist2 = cm.macd(5, 35, 5)  # 커스텀 MACD\n\n# 볼린저 밴드\nupper, middle, lower = cm.bollinger_bands()  # 기본 볼린저 밴드 (20일, 2시그마)\nupper2, middle2, lower2 = cm.bollinger_bands(10, 2.5)  # 커스텀 볼린저 밴드\n\n# 스토캐스틱\nk, d = cm.stochastic()  # 기본 스토캐스틱 (14, 3)\nk2, d2 = cm.stochastic(5, 3)  # 커스텀 스토캐스틱\n\n# ATR (평균진폭)\natr = cm.atr()  # 기본 14일 ATR\natr_5 = cm.atr(5)  # 5일 ATR\n\nresult = True",
        "type": "bool",
        "desc": "RSI, MACD, Bollinger Band, Stochastic, ATR"
    },
    "인자받는쪽": {
        "script": "m3 = ChartManager(code, 'mi', 3)\n\nshort = is_args('short', 5)\nlong = is_args('long', 10)\n\nma5 = m3.ma(short)\nma10 = m3.ma(long)\n\necho(f'{short} {long}')\n\ndn = ma10 > m3.c()\n\nresult = dn or ma5 < ma10",
        "type": "bool",
        "desc": "현재가가 10이평선을 하회하며. 5이평선이 10이평선을 하회할때"
    },
    "인자주는쪽": {
        "script": "result = 인자받는쪽(short=3, long=20)",
        "type": "bool",
        "desc": "현재가가 10이평선을 하회하며. 5이평선이 10이평선을 하회할때"
    },
    "test": {
        "script": "ct = ChartManager(code, 'mi', 3)\nma = ct.ma\necho(f'{ma(5,1)}')\n\nm5 = ct.get_ma(5, 10)\necho(f'{m5}')\necho(f'{m5[3]}\\n')\necho(f'{ct.ma(5)}')\necho(f'{ct.ma(5, 1)}')\necho(f'{ct.ma(5, 2)}')\necho(f'{ct.ma(5, 3)}')\necho(f'{ct.ma(5, 4)}')\n\n\n\nresult = True",
        "type": "bool",
        "desc": ""
    },
    "Class설정": {
        "script": "class FMA:\n    def __init__(self, code, cycle='dy', tick=1, period=20):\n        self.ct = ChartManager(code, cycle, tick)\n        self.period = period\n    \n    def ma(self, n=0):\n        return self.ct.ma(period, n)\n\n# 초기 설정\ncycle = is_args('cycle', 'dy')\ntick = is_args('tick', 1)\nperiod = is_args('period', 20) \n\nresult = FMA(code, cycle, tick, period)",
        "type": "FMA",
        "desc": "클래스를 리턴하는 스크립트"
    },
    "Class쓰기": {
        "script": "mi3 = FMA(code, 'mi', 3, 5)\n\nresult = mi3.ma()",
        "type": "float",
        "desc": "클래스를 리턴하는 스크립트를 사용하는 예"
    },
    "FMA": {
        "script": "class MA:\n    def __init__(self, code, cycle='dy', tick=1, period=20):\n        self.ct = ChartManager(code, cycle, tick)\n        self.period = period\n    \n    def ma(self, n=0):\n        return self.ct.ma(period, n)\n\n# 초기 설정\ncycle = is_args('cycle', 'dy')\ntick = is_args('tick', 1)\nperiod = is_args('period', 20) \n\n# 그냥 가능한지 해 본거고 클래스 보단 스크립트로 구현해야 함\n\nresult = MA(code, cycle, tick, period)",
        "type": "MA",
        "desc": ""
    },
    "def_함수_사용": {
        "script": "dy = ChartManager(code, 'dy')\n\necho(f'{dy.c()}')\n\n# 그냥 해 본것이고 안 하는것이 좋음 필요하면 스크립트로 작성\ndef current_price(a, b):\n    echo(f'{a} {b}')\n    mul = a * b\n    echo(f'{mul}')\n    return mul\n\nresult = current_price(3, 5)\necho(f'최종 result: {result}')",
        "type": "int",
        "desc": ""
    },
    "이동평균_사용예": {
        "script": "ct = ChartManager(code, 'mi', 3)\n\n# 기본사용\nma5 = ct.indicator(ct.avg, ct.c, 5)\necho(f'기본사용: 0={ma5(0)},1={ma5(1)},2={ma5(2)}')\n\n# 주입하여 사용\nma = ct.ma # ma에 주입\necho(f'주입사용: 0={ma(5,0)},1={ma(5,1)},2={ma(5,2)}')\n\n# 리스트로 받아와 사용\nm5 = ct.get_ma(5, 10) # 5이평 10개 받음\necho(f'리스트로: 0={m5[0]},1={m5[1]}, 2={m5[2]}')\n\n# 클래스를 정의하여 이용\nma5 = FMA(code, 'mi', 1, 5)\necho(f'클래스로: 0={m5[0]},1={m5[1]}, 2={m5[2]}')\n\n# 결론\n# 주입사용이 최고 좋다 - 빠르고 메모리 효율 좋고 유연성(동적 기간), 간결\n# 다음이 indicator - 캐싱효과 \n\nresult = True",
        "type": "bool",
        "desc": ""
    },
    "조건평가데이타": {
        "script": "ct = ChartManager(code, 'dy', 3)\n\n# 최근 종가가 60000 미만인 봉 이후로 몇 봉이 지났는지 알고 싶을 때\nbars = ct.bars_since(lambda i: ct.c(i) < 60000)\necho(f'지난봉수: {bars}')\n\n# 최근 2번째로 종가가 60000 미만 이후부터 현재까지 고가의 최고값\nhigh = ct.highest_since(2, lambda i: ct.c(i) < 60000, ct.h)\necho(f'최고가: {high}')\n\n#최근 3번째로 종가가 60000을 넘은 시점의 시가:\nopen_price = ct.value_when(3, lambda i: ct.c(i) > 200, ct.o)\necho(f'세번째: {open_price}')\n\n\nresult = True",
        "type": "bool",
        "desc": ""
    },
    "당일최고가지난봉수": {
        "script": "\ncode = '361610'\n\nct = ChartManager(code, 'mi', 3)\n\npre_bars = is_args('pre_bars', 130)\n\n# 1. 현재봉의 날짜와 시간 구하기\ncur_time = ct.time(1)  # 현재봉의 'YYYYMMDDHHMMSS' 문자열\necho(f'cur_time={cur_time}')\n\n# 2. 오늘 날짜 추출\ntoday = cur_time[:8]\n\n# 3. 오늘 9시 첫 봉의 인덱스 찾기\nresult = -1\nidx_9 = None\nfor i in range(0, 1000):  # 충분히 넉넉하게\n    t = ct.time(i)\n    if t and t[:8] == today and t[8:12] == '0900':\n        idx_9 = i\n        break\n\necho(f'idx_9={idx_9}')\nif idx_9 is None: return\n\n# 4. 9시 첫 봉부터 현재봉까지, 130봉 중 종가가 최고가인 첫 봉 찾기\nfound_idx = None\nfor m in range(idx_9, -1, -1):  # 9시 첫봉부터 현재봉(0)까지\n    # 130봉이 충분히 있는지 확인\n    if ct.time(m + 129) is None:\n        continue\n    if ct.c(m) == ct.highest(ct.h, 130, m):\n        found_idx = m\n        break\n\nif found_idx is not None:\n    echo(f\"9시 이후 첫 130봉 중 종가가 최고가인 봉의 인덱스: {found_idx}\")\n    result = found_idx\nelse:\n    echo(\"조건을 만족하는 봉이 없습니다.\")\necho(f'result = {result}')",
        "type": "int",
        "desc": ""
    },
    "개장후첫최고종가": {
        "script": "# 지정 종목\ncode = '361610'\n\n# 차트 매니저 생성 (3분봉)\ncm = ChartManager(code, 'mi', 3)\n\n# 넘겨진 인자 있는지 검사\npre_bars = is_args('pre_bars', 65)\nnth = is_args('nth', 1)\n\n# 현재봉 날짜 추출\ncurrent_time = cm.time(1)\necho(f'current_time={current_time}')\nif len(current_time) < 8:\n    result = -1\nelse:\n    current_date = current_time[:8]  # YYYYMMDD\n    target_time = current_date + \"090000\"  # 9시 봉\n\n    # 9시 봉 인덱스 찾기\n    nine_oclock_index = -1\n    data_length = len(cm._get_data())\n\n    for i in range(data_length):\n        time_str = cm.time(i)\n        if len(time_str) >= 12 and time_str[:12] == target_time[:12]:\n            nine_oclock_index = i\n            break\n    \n    echo(f'nine_oclock_index={nine_oclock_index}')\n    result = -1  # 기본값: 찾지 못함\n    found_count = 0  # 조건에 맞는 봉의 개수\n\n    if nine_oclock_index != -1:\n        # 9시 봉부터 현재봉(0)까지 역순으로 검사\n        for check_idx in range(nine_oclock_index, -1, -1):\n            current_close = cm.c(check_idx)\n\n            # 자신을 제외한 이전 pre_bars-1봉 중 최고가 구하기\n            highest_in_pre = cm.highest(cm.h, pre_bars-1, check_idx + 1)\n\n            # 현재 종가가 이전 최고가보다 높으면\n            if current_close > highest_in_pre:\n                found_count += 1\n                if found_count == nth:  # nth번째 조건 만족 봉이면\n                    result = check_idx\n                    break\n\necho(f'result = {result}')",
        "type": "int",
        "desc": ""
    }
}